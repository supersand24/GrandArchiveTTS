local zones = {
  field = {
    x = 0,
    y = 3,
    z = -5.5
  },
  memory = {
    x = 0,
    y = 3,
    z = -7.25
  },
  banishment = {
    x = -18.3,
    y = 3,
    z = -6.6
  },
  mainDeck = {
    x = -17.6,
    y = 3,
    z = -1.2
  },
  graveyard = {
    x = -17.6,
    y = 3,
    z = 4.75
  },
  tokens = {
    x = 18.3,
    y = 3,
    z = -6.6
  },
  materialDeck = {
    x = 17.6,
    y = 3,
    z = -1.2
  },
  sideboard = {
    x = 17.6,
    y = 3,
    z = 4.75
  },
}

local fieldZone = nil
local memoryZone = nil
local banishmentZone = nil
local mainDeckZone = nil
local graveyardZone = nil
local tokensZone = nil
local materialDeckZone = nil
local sideDeckZone = nil

local memoryButtonsVisible = true

local playerColor = "Blue"
local flippedBoard = true

local deckURL = "https://build.silvie.org/"

function getTokensZone()
    return tokensZone
end

function syncTextFields(player, value, id)
  --Set deckURL while trimming whitespace.
  deckURL = string.gsub(value, "%s+", "");
end

--When the Import Deck Button is pressed.
function importDeck()

  --Error Handling
  if mainDeckZone == nil then log("Main Deck Zone is nil.") return end
  if materialDeckZone == nil then log("Material Deck Zone is nil.") return end
  if sideDeckZone == nil then log("Side Deck Zone is nil.") return end
  if tokensZone == nil then log("Tokens Zone is nil.") return end

  --Append http://
  if Global.call("stringStartsWith",{string=deckURL,startsWith="https://"}) == false then
    deckURL = "https://" .. deckURL
  end

  --Silvie
  if Global.call("stringStartsWith",{string=deckURL,startsWith="https://build"}) then
    --Append ?format=json if it isn't there.
    if Global.call("stringEndsWith",{string=deckURL,endsWith="?format=json"}) == false then
      deckURL = deckURL .. "?format=json"
    end

  --Shout at your decks
  elseif Global.call("stringStartsWith",{string=deckURL,startsWith="https://www.shout"}) or Global.call("stringStartsWith",{string=deckURL,startsWith="https://shout"}) then
    --Sub http://shoutatyourdecks.com/decks/ -> http://shoutatyourdecks.com/api/
    deckURL = deckURL:gsub("/decks/","/api/")
  else
    broadcastToColor("Unknown Deck Import Link", playerColor, {255,0,0})
    return
  end

  log("Importing " .. deckURL)

  --Get Deck from URL
  WebRequest.get(deckURL, function(request)
    if request.is_error then
      log(request.error)
    else

      json = JSON.decode(request.text)

      --Check for Error from silve.org
      if json.error ~= nil then
        log(json.error)
        if json.error == "silvie/bad-request" then
          broadcastToColor("Could not find a Deck under that URL!", playerColor, {255,0,0})
        else
          broadcastToColor("Unknown Error!", playerColor, {255,0,0})
        end
      else
        --Start Spawning Cards
        --broadcastToColor("Importing " .. json.name .. " from " .. json.creator, playerColor, {255,255,255})

        Global.call("importDecks", {
          decks=json.cards,
          mainDeck={
            position = mainDeckZone.getPosition(),
            rotation = mainDeckZone.getRotation()
          },
          materialDeck={
            position = materialDeckZone.getPosition(),
            rotation = materialDeckZone.getRotation()
          },
          sideDeck={
            position = sideDeckZone.getPosition(),
            rotation = sideDeckZone.getRotation()
          }
        })

        -- Hide Import Button UI
        hideDeckImport()

      end

    end

  end)

end

function hideDeckImport()
  self.UI.hide(string.lower(playerColor) .. "DeckImport")
end

function showDeckImport()
  self.UI.show(string.lower(playerColor) .. "DeckImport")
end

function resetPlayspace()

  if fieldZone == nil then log("Field Zone is nil.") return end
  if memoryZone == nil then log("Memory Zone is nil.") return end
  if banishmentZone == nil then log("Banishment Zone is nil.") return end
  if mainDeckZone == nil then log("Main Deck Zone is nil.") return end
  if graveyardZone == nil then log("Graveyard Zone is nil.") return end
  if tokensZone == nil then log("Tokens Zone is nil.") return end
  if materialDeckZone == nil then log("Material Deck Zone is nil.") return end
  if sideDeckZone == nil then log("Side Deck Zone is nil.") return end

  for _, obj in pairs(fieldZone.getObjects()) do
    if obj.type == "Card" or obj.type == "Deck" then
      destroyObject(obj)
    end
  end

  for _, obj in pairs(memoryZone.getObjects()) do
    if obj.type == "Card" or obj.type == "Deck" then
      destroyObject(obj)
    end
  end

  for _, obj in pairs(banishmentZone.getObjects()) do
    if obj.type == "Card" or obj.type == "Deck" then
      destroyObject(obj)
    end
  end

  for _, obj in pairs(mainDeckZone.getObjects()) do
    if obj.type == "Card" or obj.type == "Deck" then
      destroyObject(obj)
    end
  end

  for _, obj in pairs(materialDeckZone.getObjects()) do
    if obj.type == "Card" or obj.type == "Deck" then
      destroyObject(obj)
    end
  end

  for _, obj in pairs(sideDeckZone.getObjects()) do
    if obj.type == "Card" or obj.type == "Deck" then
      destroyObject(obj)
    end
  end

end

function readyUp()
  Global.call("startGame")
end

function payOneMemoryCard()

  if memoryZone == nil then log("Memory Zone is nil.") return end

  local memoryCards = 0
  local memoryCheck = 0

  if (memoryZone.getObjects()) != nil then
    memoryCards = #memoryZone.getObjects()-1
    randomCard = math.random(memoryCards)

    for _,item in ipairs(memoryZone.getObjects()) do
      if item.tag == "Card" then
        memoryCheck = memoryCheck + 1
        if memoryCheck == randomCard then
          rotation = self.getRotation()
          item.setPositionSmooth(banishmentZone.getPosition())
          item.setRotationSmooth({rotation.x,rotation.y+90,rotation.z})
        end
      end
    end
  end
end

function revealRandomMemoryCard()

  if memoryZone == nil then log("Memory Zone is nil.") return end

  local memoryCards = 0
  local memoryCheck = 0

  if (memoryZone.getObjects()) != nil then
    memoryCards = #memoryZone.getObjects()-1
    randomCard = math.random(memoryCards)

    for _,item in ipairs(memoryZone.getObjects()) do
      if item.tag == "Card" then
        memoryCheck = memoryCheck + 1
        if memoryCheck == randomCard then
          item.flip()
        end
      end
    end
  end
end

function recollectMemory()

  if memoryZone == nil then log("Memory Zone is nil.") return end

  if (memoryZone.getObjects()) != nil then
    for _,item in ipairs(memoryZone.getObjects()) do
      if item.tag == "Card" then
        item.deal(1,playerColor)
      end
    end
  end

end

function hideMemoryButtons()

  memoryButtonsVisible = not memoryButtonsVisible

  if memoryButtonsVisible then
    self.UI.show(string.lower(playerColor) .. "MemoryButtons")
  else
    self.UI.hide(string.lower(playerColor) .. "MemoryButtons")
  end

end

function spawnZones()
  boardPos = self.getPosition()

  if flippedBoard then
    mod = -1
  else
    mod = 1
  end

  fieldZone = spawnObject({
    type              = 'ScriptingTrigger',
    position          = {
      boardPos.x + (zones.field.x * mod),
      2,
      boardPos.z + (zones.field.z * mod)
    },
    rotation          = self.getRotation(),
    scale             = {30,2,15},
    sound             = false,
    snap_to_grid      = false,
  })

  memoryZone = spawnObject({
    type              = 'ScriptingTrigger',
    position          = {
      boardPos.x + (zones.memory.x * mod),
      2,
      boardPos.z - (zones.memory.z * mod)
    },
    rotation          = self.getRotation(),
    scale             = {30,2,10},
    sound             = false,
    snap_to_grid      = false,
  })

  graveyardZone = spawnObject({
    type              = 'ScriptingTrigger',
    position          = {
      boardPos.x + (zones.graveyard.x * mod),
      2,
      boardPos.z + (zones.graveyard.z * mod)
    },
    rotation          = self.getRotation(),
    scale             = {4,2,5},
    sound             = false,
    snap_to_grid      = false,
  })

  mainDeckZone = spawnObject({
    type              = 'ScriptingTrigger',
    position          = {
      boardPos.x + (zones.mainDeck.x * mod),
      2,
      boardPos.z + (zones.mainDeck.z * mod)
    },
    rotation          = self.getRotation(),
    scale             = {4,2,5},
    sound             = false,
    snap_to_grid      = false,
  })

  banishmentZone = spawnObject({
    type              = 'ScriptingTrigger',
    position          = {
      boardPos.x + (zones.banishment.x * mod),
      2,
      boardPos.z + (zones.banishment.z * mod)
    },
    rotation          = self.getRotation(),
    scale             = {5,2,4},
    sound             = false,
    snap_to_grid      = false,
  })

  tokensZone = spawnObject({
    type              = 'ScriptingTrigger',
    position          = {
      boardPos.x + (zones.tokens.x * mod),
      2,
      boardPos.z + (zones.tokens.z * mod)
    },
    rotation          = self.getRotation(),
    scale             = {5,2,4},
    sound             = false,
    snap_to_grid      = false,
  })

  materialDeckZone = spawnObject({
    type              = 'ScriptingTrigger',
    position          = {
      boardPos.x + (zones.materialDeck.x * mod),
      2,
      boardPos.z + (zones.materialDeck.z * mod)
    },
    rotation          = self.getRotation(),
    scale             = {4,2,5},
    sound             = false,
    snap_to_grid      = false,
  })

  sideDeckZone = spawnObject({
    type              = 'ScriptingTrigger',
    position          = {
      boardPos.x + (zones.sideboard.x * mod),
      2,
      boardPos.z + (zones.sideboard.z * mod)
    },
    rotation          = self.getRotation(),
    scale             = {4,2,5},
    sound             = false,
    snap_to_grid      = false,
  })

end

function onLoad()

  --Prevent ALT Interaction
  self.interactable = true

  self.addContextMenuItem("Spawn Zones", spawnZones)

  snapPoints = {

      -- Left Side

      -- Damage Taken Counter
      { position = { (zones.tokens.x / self.getScale().x), 0, (zones.tokens.z / self.getScale().z) - 0.3 },
        rotation = {0,180,0},
        rotation_snap = true,
        tags = {"Game Counter"}
      },

      -- Tokens
      { position = { (zones.tokens.x / self.getScale().x), 0, (zones.tokens.z / self.getScale().z) },
        rotation = {0,270,0},
        rotation_snap = true
      },

      -- Material Deck
      { position = { (zones.materialDeck.x / self.getScale().x), 0, (zones.materialDeck.z / self.getScale().z) },
        rotation = {0,0,0},
        rotation_snap = true
      },

      -- Side Deck
      { position = { (zones.sideboard.x / self.getScale().x), 0, (zones.sideboard.z / self.getScale().z) },
        rotation = {0,0,0},
        rotation_snap = true
      },

      -- Right Side

      -- Banishment Etc Counter
      { position = { (zones.mainDeck.x / self.getScale().x), 0, (zones.banishment.z / self.getScale().z) - 0.25 },
        rotation = {0,180,0},
        rotation_snap = true,
        tags = {"Game Counter"}
      },

      -- Banishment
      { position = { (zones.banishment.x / self.getScale().x), 0, (zones.banishment.z / self.getScale().z) },
        rotation = {0,90,0},
        rotation_snap = true
      },

      -- Main Deck
      { position = { (zones.mainDeck.x / self.getScale().x), 0, (zones.mainDeck.z / self.getScale().z) },
        rotation = {0,0,0},
        rotation_snap = true
      },

      -- Draw Counter
      { position = { (zones.mainDeck.x / self.getScale().x) - 0.25, 0, (zones.mainDeck.z / self.getScale().z) },
        rotation = {0,270,0},
        rotation_snap = true,
        tags = {"Game Counter"}
      },

      -- Graveyard
      { position = { (zones.graveyard.x / self.getScale().x), 0, (zones.graveyard.z / self.getScale().z) },
        rotation = {0,0,0},
        rotation_snap = true
      },

      -- Graveyard Floating Memory Counter
      { position = { (zones.graveyard.x / self.getScale().x), 0, (zones.graveyard.z / self.getScale().z) + 0.3 },
        rotation = {0,180,0},
        rotation_snap = true,
        tags = {"Game Counter"}
      },

      -- Graveyard Etc Counter
      { position = { (zones.graveyard.x / self.getScale().x), 0, (zones.graveyard.z / self.getScale().z) + 0.5 },
        rotation = {0,180,0},
       rotation_snap = true,
        tags = {"Game Counter"}
      },

  }

  -- Field Snap Points
  fieldRow = {}
  fieldRow[1] = 0
  fieldRow[2] = fieldRow[1] - 0.185
  fieldRow[3] = fieldRow[2] - 0.185
  fieldRow[4] = fieldRow[3] - 0.185
  fieldRow[5] = fieldRow[4] - 0.185
  fieldCardSpacing = 0.175
  for _, row in ipairs(fieldRow) do
    for i=-6, 6 do
      snapPoints[#snapPoints + 1] = { position = {fieldCardSpacing*i,0,row},
                                      rotation = {0,0,0},
                                      rotation_snap = false,
                                      tags = {"Card"}
                                    }
    end
  end

  -- Memory Snap Points
  memoryRow = {}
  memoryRow[1] = 0.475
  memoryRow[2] = memoryRow[1] + 0.185
  memoryCardSpacing = 0.135
  for _, row in ipairs(memoryRow) do
    for i=-8, 8 do
      snapPoints[#snapPoints + 1] = { position = {memoryCardSpacing*i,0,row},
                                      rotation = {0,0,0},
                                      rotation_snap = true,
                                      tags = {"Card"}
                                    }
    end
  end

  self.setSnapPoints(snapPoints)
end